<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Slides</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/equilibrium-gray-light.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Project 01 -->
        <section>
          <h1>SC2001 Project 01</h1>
          <p>
            Integration of
            <b style="text-shadow: 0 0 10px #789777">Merge Sort</b>
            and
            <b style="text-shadow: 0 0 10px #897757">Insertion Sort</b>
          </p>
          <p><b>Team 5</b></p>
        </section>

        <section><h2>Algorithm Implementation</h2></section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #c86767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #c86767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  return 0;
                }
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #c86767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                using namespace std;

                using ll = long long;

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  vector<int> a;

                  return 0;
                }
                </script>
              </code>
            </pre>
        </section>

        <section>
          <h3>Insertion Sort</h3>
          <pre>
              <code data-line-numbers="1-12|1|2|3-11" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto insertion_sort = [&](int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  ll cmps = 0LL;
                  for (int i = l + 1; i <= r; i++) {
                    for (int j = i; j >= l + 1; j--) {
                      cmps++;
                      if (a[j] < a[j - 1]) swap(a[j], a[j - 1]);
                      else break;
                    }
                  }
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge</h3>
          <pre>
              <code data-line-numbers="1-15|2-3|4-12|13-14" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge = [&](int l, int m, int r) -> ll {
                  ll cmps = 0LL;
                  vector<int> merged;
                  for (int i = l, j = m + 1; i <= m || j <= r;) {
                    if (i == m + 1) merged.push_back(a[j++]);
                    else if (j == r + 1) merged.push_back(a[i++]);
                    else {
                      cmps++;
                      if (a[i] < a[j]) merged.push_back(a[i++]);
                      else merged.push_back(a[j++]);
                    }
                  }
                  ranges::copy(merged, begin(a) + l);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge Sort</h3>
          <pre>
              <code data-line-numbers="1-7|1|2|3-4|5-6" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge_sort = [&](this auto &&self, int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m) + self(m + 1, r);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
          <blockquote>
            <b><i>deducing this</i></b> is a C++23 feature; you might opt for a
            <b><i>y-combinator</i></b> instead.
          </blockquote>
        </section>

        <section>
          <h3>Hybrid Sort</h3>
          When the subarray size falls below a threshold, we'll switch to
          Insertion Sort instead.
          <pre>
              <code data-line-numbers="1-8|1|2|3|4-7" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto hybrid_sort = [&](this auto &&self, int l, int r, int s = 1) -> ll {
                  if (l >= r) return 0LL;
                  if (r - l + 1 <= s) return insertion_sort(l, r);
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m, s) + self(m + 1, r, s);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Random Array Generation</h2></section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
          <p>
            For debugging purposes, here's a snippet that lets us inspect the
            contents of the array:
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                auto display = [&]() -> void {
                  cout << "{ ";
                  for (int i = 0; i < ssize(a); i++) {
                    cout << a[i] << " ";
                  }
                  cout << "}\n";
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Time Complexity Analysis</h2></section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
        </section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
          <div
            data-id="math-animation"
            style="border: 4px solid #222222; border-radius: 14px"
          >
            $n$
          </div>
        </section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
          <div
            data-id="math-animation"
            style="border: 4px solid #222222; border-radius: 14px"
          >
            $n$
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
          </div>
        </section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
          <div
            data-id="math-animation"
            style="border: 4px solid #222222; border-radius: 14px"
          >
            $n$
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
          </div>
        </section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
          <div
            data-id="math-animation"
            style="border: 4px solid #222222; border-radius: 14px"
          >
            $n$
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
          </div>
        </section>

        <section data-auto-animate>
          <p>Let's begin with a theoretical analysis.</p>
          <div
            data-id="math-animation"
            style="border: 4px solid #222222; border-radius: 14px"
          >
            $n$
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/2$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $n/4$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $\cdots$
            </div>
          </div>
          <br />
          <div
            data-id="math-animation"
            ;
            style="display: flex; justify-content: space-between; gap: 14px"
          >
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
            <div
              style="
                width: 100%;
                border: 4px solid #222222;
                border-radius: 14px;
              "
            >
              $S$
            </div>
          </div>
          <blockquote>
            In total, there are $\log_2(\frac{n}{S})$ layers. At the final
            layer, there are $\frac{n}{S}$ segments.
          </blockquote>
        </section>

        <section data-auto-animate>
          <h3 style="text-shadow: 0 0 10px #789777">Best Case</h3>
        </section>

        <section data-auto-animate>
          <h3 style="text-shadow: 0 0 10px #789777">Best Case</h3>
          <p>
            The time complexity of running insertion sort on the bottom layer is
            $\frac{n}{S} \cdot \mathcal{O}(S) = \mathcal{O}(n)$.
          </p>
          <p>
            On the other hand, merging the $\log_2(\frac{n}{S})$ layers would
            cost $\mathcal{O}(n \cdot \log_2(\frac{n}{S}))$.
          </p>
        </section>

        <section data-auto-animate>
          <h3 style="text-shadow: 0 0 10px #789777">Best Case</h3>
          <p>
            The time complexity of running insertion sort on the bottom layer is
            $\frac{n}{S} \cdot \mathcal{O}(S) = \mathcal{O}(n)$.
          </p>
          <p>
            On the other hand, merging the $\log_2(\frac{n}{S})$ layers would
            cost $\mathcal{O}(n \cdot \log_2(\frac{n}{S}))$.
          </p>
          <blockquote>
            Naturally, the total time complexity is the <i>sum</i> of the two,
            that is, $\mathcal{O}(n + n \cdot \log_2(\frac{n}{S}))$.
          </blockquote>
        </section>

        <section data-auto-animate="">
          <h3 style="text-shadow: 0 0 10px #c86767">Average/Worst Case</h3>
          <p>
            In the average/worst case, merging has the same time complexity of
            $\mathcal{O}(n + n \cdot \log_2(\frac{n}{S}))$. However, during
            insertion sort, we'll acquire a higher time complexity of
            $\frac{n}{S} \cdot \mathcal{O}(S^2) = \mathcal{O}(nS)$.
          </p>
        </section>

        <section data-auto-animate>
          <h3 style="text-shadow: 0 0 10px #c86767">Average/Worst Case</h3>
          <p>
            In the average/worst case, merging has the same time complexity of
            $\mathcal{O}(n + n \cdot \log_2(\frac{n}{S}))$. However, during
            insertion sort, we'll acquire a higher time complexity of
            $\frac{n}{S} \cdot \mathcal{O}(S^2) = \mathcal{O}(nS)$.
          </p>
          <blockquote>
            The time complexity is $\mathcal{O}(nS + n \cdot
            \log_2(\frac{n}{S}))$.
          </blockquote>
        </section>

        <section>
          <h2>Part (i)</h2>
        </section>

        <section>
          <blockquote>
            For the subsequent experiments measuring the number of key
            comparisons/runtime, we'll always take the mean of <i>five</i>
            samples.
          </blockquote>
        </section>

        <section data-auto-animate>
          <p>
            First, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            First, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            First, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            First, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_1000000_10000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section>
          <h2>Part (ii)</h2>
        </section>

        <section>
          <p>
            Instead of varying <b>n</b>, let us now fix <b>n</b> at
            <b>10,000</b> and vary <b>s</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_ii.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate="">
          <blockquote data-id="blockquote-animation">
            Intuitively, it appears that the <i>lower</i> the threshold
            <b>s</b>, the better the performance.
          </blockquote>
        </section>

        <section data-auto-animate>
          <blockquote data-id="blockquote-animation">
            Intuitively, it appears that the <i>lower</i> the threshold
            <b>s</b>, the better the performance.
          </blockquote>
          <br />
          <p>
            As <b>s</b> increases, we are no longer leveraging the
            divide-and-conquer principle of Merge Sort and instead relying more
            heavily on Insertion Sort.
          </p>
        </section>

        <section>
          <h2>Interlude: Closing the Gap</h2>
        </section>

        <section data-auto-animate>
          <p>
            Although we have established the time complexities earlier, let's
            find a better estimate for the average case.
          </p>
        </section>

        <section data-auto-animate="">
          <p>
            Although we have established the time complexities earlier, let's
            find a better estimate for the average case.
          </p>
          <blockquote data-id="blockquote-animation">
            Interestingly, for large $n$ and a randomly ordered array, merge
            sort's expected number of comparisons approaches $\alpha n$ less
            than the worst case (Jayalakshmi, 2007), where \[\alpha = -1 +
            \sum_{k=0}^{\infty} \frac{1}{2^k + 1} \approx 0.2645.\]
          </blockquote>
        </section>

        <section data-auto-animate="">
          <p>
            Although we have established the time complexities earlier, let's
            find a better estimate for the average case.
          </p>
          <blockquote data-id="blockquote-animation">
            Interestingly, for large $n$ and a randomly ordered array, merge
            sort's expected number of comparisons approaches $\alpha n$ less
            than the worst case (Jayalakshmi, 2007), where \[\alpha = -1 +
            \sum_{k=0}^{\infty} \frac{1}{2^k + 1} \approx 0.2645.\]
          </blockquote>
          <p>
            In addition, the number of merge layers for some arbitrary $n$ is \[
            h = \left\lfloor \log_2(\left\lceil \frac{n}{S} \right\rceil - 1)
            \right\rfloor + 1. \]
          </p>
        </section>

        <section data-auto-animate>
          <blockquote data-id="blockquote-animation-new">
            Regarding insertion sort, the average case produces \[
            \frac{(b-1)b}{4} + b - H_b \] comparisons, where $H_b =
            \sum_{i=1}^{b} \frac{1}{i}$, and $H_b \approx \ln b$ when $b \to
            \infty$ (Georgy, 2016).
          </blockquote>
        </section>

        <section data-auto-animate="">
          <blockquote data-id="blockquote-animation-new">
            Regarding insertion sort, the average case produces \[
            \frac{(b-1)b}{4} + b - H_b \] comparisons, where $H_b =
            \sum_{i=1}^{b} \frac{1}{i}$, and $H_b \approx \ln b$ when $b \to
            \infty$ (Georgy, 2016).
          </blockquote>
          <p>
            Observe that $b$ is <b>not</b> necessarily $S$. Instead, it will be
            <i>at least</i> $\left\lfloor \frac{n}{2^h} \right\rfloor$.
            Therefore, our revised estimate is \[ \left[ \frac{(b-1)n}{4} + n -
            n \cdot \frac{\ln b}{b} \right] + 0.7355 nh, \] where $b =
            \left\lfloor \frac{n}{2^h} \right\rfloor$.
          </p>
        </section>

        <section data-auto-animate>
          <p>
            Certain tricks may be used in C++ to make implementation easier.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                auto ceil_div = [](int p, int q) { return (p + q - 1) / q; };
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            Certain tricks may be used in C++ to make implementation easier.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                auto ceil_div = [](int p, int q) { return (p + q - 1) / q; };

                auto f = [&](int n, int s) {
                  int h    = __lg(ceil_div(n, s) - 1) + 1;
                  double b = n >> h;
                  return ((b - 1) * n / 4.0) + n - n * (log(b) / b) + 0.7355 * n * h;
                };
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            Reexamining part (i) with a fixed <b>S</b> of <b>50</b>, we yield
            the following graph.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_rev_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            Reexamining part (i) with a fixed <b>S</b> of <b>50</b>, we yield
            the following graph.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_rev_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            Reexamining part (i) with a fixed <b>S</b> of <b>50</b>, we yield
            the following graph.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_rev_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            Reexamining part (i) with a fixed <b>S</b> of <b>50</b>, we yield
            the following graph.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_rev_1000000_10000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section>
          <p>
            Reexamining part (ii), with a fixed <b>n</b> of <b>10,000</b>, we
            yield the following graph.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_ii_rev.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section>
          <h2>Part (iii)</h2>
        </section>

        <section data-auto-animate>
          <p>
            Knowing that the optimal <b>s</b> in the earlier example lies
            between <b>0</b> to <b>50</b>, we'll focus our search within this
            range over a variety of array sizes.
          </p>
        </section>

        <section data-auto-animate>
          <p>
            Knowing that the optimal <b>s</b> in the earlier example lies
            between <b>0</b> to <b>50</b>, we'll focus our search within this
            range over a variety of array sizes.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_iii.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
          <blockquote data-id="blockquote-animation">
            What if we measured <i>runtime</i> instead?
          </blockquote>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
          <blockquote data-id="blockquote-animation">
            What if we measured <i>runtime</i> instead?
          </blockquote>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                struct Timer {
                  using Clock        = std::chrono::steady_clock;
                  using Milliseconds = std::chrono::milliseconds;
                  void reset() { t = Clock::now(); }
                  double getElapsed() {
                    auto elapsed = Clock::now() - t;
                    return std::chrono::duration_cast<Milliseconds>(elapsed).count();
                  }

                private:
                  std::chrono::time_point<Clock> t{ Clock::now() };
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <p>
            As evidenced by the chart below, the optimal threshold size is
            <b>40</b>. Therefore, we'll use this value for our subsequent
            comparisons.
          </p>
          <blockquote>
            To determine the best <b>S</b>, we took the mean of the best
            <b>S</b> for each of the four <b>n</b> values below.
          </blockquote>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_iii_runtime.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section><h2>Comparison With Merge Sort</h2></section>

        <section data-auto-animate>
          <p>
            In terms of key comparisons, Merge Sort always beats Hybrid Sort.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_cmp_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            In terms of key comparisons, Merge Sort always beats Hybrid Sort.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_cmp_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            In terms of key comparisons, Merge Sort always beats Hybrid Sort.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_cmp_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            From a runtime perspective, at small array sizes, Hybrid Sort is
            sometimes <b>twice</b> as fast as Insertion Sort.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            At medium array sizes, Hybrid Sort offers an approximately
            <b>20%</b> speedup.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            At large array sizes, Hybrid Sort is slightly (<b>15%</b>) faster
            than Merge Sort.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section><h2>Runtime Quirks</h2></section>

        <section>
          <p>
            Interestingly, at large powers of two, <b>cache conflicts</b> are
            likely to occur, leading to seemingly strange peaks at such array
            sizes.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/extra_cache.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            The way your code is compiled also affects the runtime. Consider the
            following snippet:
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #pragma GCC optimize("Ofast,unroll-loops")
                </script>
              </code>
          </pre>
          <p>
            Putting this at the top of the c++ file led to a decrease from 6.8ms
            to 5.5ms (<b>n</b> = <b>10,000,000</b>).
          </p>
        </section>

        <section data-auto-animate>
          <p>
            The way your code is compiled also affects the runtime. Consider the
            following snippet:
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #pragma GCC optimize("Ofast,unroll-loops")
                </script>
              </code>
          </pre>
          <p>
            Putting this at the top of the c++ file led to a decrease from 6.8ms
            to 5.5ms (<b>n</b> = <b>10,000,000</b>).
          </p>
          <blockquote>
            By turning on all optimizations and unrolling loops as aggressively
            as possible, the compiled program runs even faster. Unfortunately,
            it assumes that you are using GCC and this isn't always guaranteed
            to work...
          </blockquote>
        </section>

        <section>
          <h1>Thank You</h1>
          <blockquote>
            <a href="https://github.com/anAcc22/SC2001_Group_Project">
              https://github.com/anAcc22/SC2001_Group_Project
            </a>
          </blockquote>
        </section>

        <section>
          <h3>References</h3>
          <ul style="font-size: 26px">
            <li>
              Gimel’farb, G. (2016). Insertion sort: Analysis of complexity.
              https://www.cs.auckland.ac.nz/compsci220s1c/lectures/2016S1C/CS220-Lecture08.pdf
            </li>
            <li>
              Jayalakshmi, N. (2007). Data structure using C++. Firewall Media.
              ISBN 978-81-318-0020-1. OCLC 849900742
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/math/math.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <!-- Chart Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/chart/plugin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.2.0/chart.min.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/

      Chart.defaults.font.family = "Maple Mono";
      Chart.defaults.font.size = 16;

      Reveal.initialize({
        hash: true,

        transition: "slide",
        autoAnimateDuration: 0.8,

        maxScale: 1.0, // PERF: resolves blurry font issue
        minScale: 0.2,

        chart: {
          defaults: {
            color: "#121212",
            scale: {
              grid: {
                color: "#424242",
              },
            },
          },
          line: {
            borderColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            borderDash: [
              [0, 0],
              [0, 0],
            ],
          },
          scatter: {
            borderColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            backgroundColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            borderDash: [
              [0, 0],
              [0, 0],
              [0, 0],
            ],
            pointRadius: [1, 1, 1],
          },
        },

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealChart,
          RevealMath.KaTeX,
        ],
      });
    </script>
  </body>
</html>
