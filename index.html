<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Slides</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/equilibrium-gray-light.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Project 01 -->
        <section>
          <h1>SC2001 Project 01</h1>
          <p>
            Integration of
            <b style="text-shadow: 0 0 10px #789777">Merge Sort</b>
            and
            <b style="text-shadow: 0 0 10px #897757">Insertion Sort</b>
          </p>
        </section>

        <section><h2>Algorithm Implementation</h2></section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  return 0;
                }
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                using namespace std;

                using ll = long long;

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  vector<int> a;

                  return 0;
                }
                </script>
              </code>
            </pre>
        </section>

        <section>
          <h3>Insertion Sort</h3>
          <pre>
              <code data-line-numbers="1-12|1|2|3-11" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto insertion_sort = [&](int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  ll cmps = 0LL;
                  for (int i = l + 1; i <= r; i++) {
                    for (int j = i; j >= l + 1; j--) {
                      cmps++;
                      if (a[j] < a[j - 1]) swap(a[j], a[j - 1]);
                      else break;
                    }
                  }
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge</h3>
          <pre>
              <code data-line-numbers="1-15|2-3|4-12|13-14" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge = [&](int l, int m, int r) -> ll {
                  ll cmps = 0LL;
                  vector<int> merged;
                  for (int i = l, j = m + 1; i <= m || j <= r;) {
                    if (i == m + 1) merged.push_back(a[j++]);
                    else if (j == r + 1) merged.push_back(a[i++]);
                    else {
                      cmps++;
                      if (a[i] < a[j]) merged.push_back(a[i++]);
                      else merged.push_back(a[j++]);
                    }
                  }
                  ranges::copy(merged, begin(a) + l);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge Sort</h3>
          <pre>
              <code data-line-numbers="1-7|1|2|3-4|5-6" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge_sort = [&](this auto &&self, int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m) + self(m + 1, r);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
          <blockquote>
            <b><i>deducing this</i></b> is a C++23 feature; you might opt for a
            <b><i>y-combinator</i></b> instead.
          </blockquote>
        </section>

        <section>
          <h3>Hybrid Sort</h3>
          When the subarray size falls below a threshold, we'll switch to
          Insertion Sort instead.
          <pre>
              <code data-line-numbers="1-8|1|2|3|4-7" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto hybrid_sort = [&](this auto &&self, int l, int r, int s = 1) -> ll {
                  if (l >= r) return 0LL;
                  if (r - l + 1 <= s) return insertion_sort(l, r);
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m, s) + self(m + 1, r, s);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Random Array Generation</h2></section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
          <p>
            For debugging purposes, here's a snippet that lets us inspect the
            contents of the array:
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                auto display = [&]() -> void {
                  cout << "{ ";
                  for (int i = 0; i < ssize(a); i++) {
                    cout << a[i] << " ";
                  }
                  cout << "}\n";
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Time Complexity Analysis</h2></section>

        <section>
          <p>Let's begin with a theoretical analysis.</p>
        </section>

        <section>
          <h2>Part (i)</h2>
        </section>

        <section data-auto-animate>
          <p>
            Next, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <p>For each <b>n</b>, we take the mean of <i>five</i> samples.</p>
        </section>

        <section data-auto-animate>
          <p>
            Next, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <p>For each <b>n</b>, we take the mean of <i>five</i> samples.</p>
        </section>

        <section data-auto-animate>
          <p>
            Next, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <p>For each <b>n</b>, we take the mean of <i>five</i> samples.</p>
        </section>

        <section data-auto-animate>
          <p>
            Next, let's fix the value of <b>s</b> at <b>50</b> and observe how
            the number of key comparisons changes with <b>n</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_i_1000000_10000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <p>For each <b>n</b>, we take the mean of <i>five</i> samples.</p>
        </section>

        <section>
          <h2>Part (ii)</h2>
        </section>

        <section>
          <p>
            Instead of varying <b>n</b>, let us now fix <b>n</b> at
            <b>10,000</b> and vary <b>s</b>.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_ii.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <p>For each <b>s</b>, we take the mean of <i>five</i> samples.</p>
        </section>

        <section data-auto-animate="">
          <blockquote data-id="blockquote-animation">
            Intuitively, it appears that the <i>lower</i> the threshold
            <b>s</b>, the better the performance.
          </blockquote>
        </section>

        <section data-auto-animate>
          <blockquote data-id="blockquote-animation">
            Intuitively, it appears that the <i>lower</i> the threshold
            <b>s</b>, the better the performance.
          </blockquote>
          <br />
          <p>
            As <b>s</b> increases, we are no longer leveraging the
            divide-and-conquer principle of Merge Sort and instead relying more
            heavily on Insertion Sort.
          </p>
        </section>

        <section>
          <h2>Part (iii)</h2>
        </section>

        <section data-auto-animate>
          <p>
            Knowing that the optimal <b>s</b> in the earlier example lies
            between <b>1</b> to <b>50</b>, we'll focus our search within this
            range over a variety of array sizes. Like before, we'll use the mean
            of five samples.
          </p>
        </section>

        <section data-auto-animate>
          <p>
            Knowing that the optimal <b>s</b> in the earlier example lies
            between <b>1</b> to <b>50</b>, we'll focus our search within this
            range over a variety of array sizes. Like before, we'll use the mean
            of five samples.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_iii.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Key Comparisons", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
          <blockquote>What if we measured <i>runtime</i> instead?</blockquote>
        </section>

        <section data-auto-animate>
          <p>
            It appears that from the POV of key comparisons, the lower the
            threshold size, the better the performance, i.e., we should just
            stick to Merge Sort instead.
          </p>
          <blockquote>What if we measured <i>runtime</i> instead?</blockquote>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                struct Timer {
                  using Clock        = std::chrono::steady_clock;
                  using Milliseconds = std::chrono::milliseconds;
                  void reset() { t = Clock::now(); }
                  double getElapsed() {
                    auto elapsed = Clock::now() - t;
                    return std::chrono::duration_cast<Milliseconds>(elapsed).count();
                  }

                private:
                  std::chrono::time_point<Clock> t{ Clock::now() };
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <p>
            As evidenced by the chart below, the optimal threshold size lies at
            around <b>30</b>. Therefore, we'll use this value for our subsequent
            comparison.
          </p>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_iii_runtime.txt"
              style="height: 45vh"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Threshold Size (s)", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
        </section>

        <section><h2>Comparison With Merge Sort</h2></section>

        <section data-auto-animate>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_1000_10000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <blockquote>
            At small array sizes, Hybrid Sort is sometimes <b>twice</b> as fast
            as Insertion Sort.
          </blockquote>
        </section>

        <section data-auto-animate>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_10000_100000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <blockquote>
            At medium array sizes, Hybrid Sort offers an approximately
            <b>20%</b> speedup.
          </blockquote>
        </section>

        <section data-auto-animate>
          <div>
            <canvas
              data-chart="line"
              data-chart-src="project_01/part_d_100000_1000000.txt"
              style="height: 45vh"
              data-id="animate-chart"
            >
              <!--
            {
              "options": {
                "animation": false,
                "scales": {
                  "y": {
                    "title": {
                      "text": "Runtime (ms)", "display": true
                    }
                  },
                  "x": {
                    "title": {
                      "text": "Array Size", "display": true
                    }
                  }
                }
              }
            }
            -->
            </canvas>
          </div>
          <blockquote>
            At large array sizes, Hybrid Sort is slightly (<b>15%</b>) faster
            than Merge Sort.
          </blockquote>
        </section>

        <section>
          <h1>Thank You</h1>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/math/math.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <!-- Chart Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/chart/plugin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.2.0/chart.min.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/

      Chart.defaults.font.family = "Maple Mono";
      Chart.defaults.font.size = 16;

      Reveal.initialize({
        hash: true,

        transition: "slide",
        autoAnimateDuration: 0.8,

        maxScale: 1.0, // PERF: resolves blurry font issue
        minScale: 0.2,

        chart: {
          defaults: {
            color: "#121212",
            scale: {
              grid: {
                color: "#424242",
              },
            },
          },
          line: {
            borderColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            borderDash: [
              [0, 0],
              [0, 0],
            ],
          },
          scatter: {
            borderColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            backgroundColor: ["#447754d1", "#824232d1", "#826222d1", "#6687b1"],
            borderDash: [
              [0, 0],
              [0, 0],
              [0, 0],
            ],
            pointRadius: [1, 1, 1],
          },
        },

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealChart,
          RevealMath.KaTeX,
        ],
      });
    </script>
  </body>
</html>
