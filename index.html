<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Slides</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/equilibrium-gray-light.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Project 01 -->
        <section>
          <h1>SC2001 Project 01</h1>
          <p>
            Integration of
            <b style="text-shadow: 0 0 10px #789777">Merge Sort</b>
            and
            <b style="text-shadow: 0 0 10px #897757">Insertion Sort</b>
          </p>
        </section>

        <section><h2>Algorithm Implementation</h2></section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  return 0;
                }
                </script>
              </code>
            </pre>
        </section>

        <section data-auto-animate>
          <h3>Initial Setup</h3>
          <p>
            We've opted to use
            <b style="text-shadow: 0 0 10px #986767">C++</b>
            for this project. Specifically, we're using C++23, along with the
            GCC 14.2 compiler.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                #include <bits/stdc++.h>

                using namespace std;

                using ll = long long;

                int main() {
                  cin.tie(nullptr)->sync_with_stdio(false);

                  vector<int> a;

                  return 0;
                }
                </script>
              </code>
            </pre>
        </section>

        <section>
          <h3>Insertion Sort</h3>
          <pre>
              <code data-line-numbers="1-12|1|2|3-11" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto insertion_sort = [&](int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  ll cmps = 0LL;
                  for (int i = l + 1; i <= r; i++) {
                    for (int j = i; j >= l + 1; j--) {
                      cmps++;
                      if (a[j] < a[j - 1]) swap(a[j], a[j - 1]);
                      else break;
                    }
                  }
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge</h3>
          <pre>
              <code data-line-numbers="1-15|2-3|4-12|13-14" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge = [&](int l, int m, int r) -> ll {
                  ll cmps = 0LL;
                  vector<int> merged;
                  for (int i = l, j = m + 1; i <= m || j <= r;) {
                    if (i == m + 1) merged.push_back(a[j++]);
                    else if (j == r + 1) merged.push_back(a[i++]);
                    else {
                      cmps++;
                      if (a[i] < a[j]) merged.push_back(a[i++]);
                      else merged.push_back(a[j++]);
                    }
                  }
                  ranges::copy(merged, begin(a) + l);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section>
          <h3>Merge Sort</h3>
          <pre>
              <code data-line-numbers="1-7|1|2|3-4|5-6" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto merge_sort = [&](this auto &&self, int l, int r) -> ll {
                  if (l >= r) return 0LL;
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m) + self(m + 1, r);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
          <blockquote>
            <b><i>deducing this</i></b> is a C++23 feature; you might opt for a
            <b><i>y-combinator</i></b> instead.
          </blockquote>
        </section>

        <section>
          <h3>Hybrid Sort</h3>
          When the subarray size falls below a threshold, we'll switch to
          Insertion Sort instead.
          <pre>
              <code data-line-numbers="1-8|1|2|3|4-7" data-trim data-noescape class="cpp">
                <script type="text/template">
                auto hybrid_sort = [&](this auto &&self, int l, int r, int s = 1) -> ll {
                  if (l >= r) return 0LL;
                  if (r - l + 1 <= s) return insertion_sort(l, r);
                  int m   = midpoint(l, r);
                  ll cmps = self(l, m, s) + self(m + 1, r, s);
                  cmps += merge(l, m, r);
                  return cmps;
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Random Array Generation</h2></section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre data-id="code-animation">
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
        </section>

        <section data-auto-animate>
          <p>
            To fill an array with random numbers, we'll use the
            <b>Mersenne Twister pseudo-random generator</b> available in the
            standard library.
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                random_device dev;
                mt19937 gen(dev());

                uniform_int_distribution dist(1, INT_MAX);

                auto build = [&](int size) -> void {
                  a.resize(size);
                  ranges::generate(a, [&]() { return dist(gen); });
                };
                </script>
              </code>
          </pre>
          <p>
            For debugging purposes, here's a snippet that lets us inspect the
            contents of the array:
          </p>
          <pre>
              <code data-line-numbers data-trim data-noescape class="cpp">
                <script type="text/template">
                auto display = [&]() -> void {
                  cout << "{ ";
                  for (int i = 0; i < ssize(a); i++) {
                    cout << a[i] << " ";
                  }
                  cout << "}\n";
                };
                </script>
              </code>
          </pre>
        </section>

        <section><h2>Time Complexity Analysis</h2></section>

        <section>
          Let's begin with a theoretical analysis of the time complexity.
        </section>

        <section><h2>Comparison With Merge Sort</h2></section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/math/math.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        transition: "slide",
        autoAnimateDuration: 0.8,

        maxScale: 1.0, // PERF: resolves blurry font issue
        minScale: 0.2,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealMath.KaTeX,
        ],
      });
    </script>
  </body>
</html>
